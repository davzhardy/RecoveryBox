{"version":3,"sources":["Hooks.ts"],"names":["useNavigation","navigation","NavigationContext","Error","useNavigationParam","paramName","getParam","useNavigationState","state","useNavigationKey","key","useGetter","value","ref","current","useNavigationEvents","callback","getLatestCallback","subscribedCallback","event","latestCallback","subs","addListener","forEach","sub","remove","emptyFocusState","isFocused","isBlurring","isBlurred","isFocusing","didFocusState","willBlurState","didBlurState","willFocusState","nextFocusState","eventName","currentState","useFocusState","focusState","setFocusState","e","currentFocusState","type","useFocusEffect","cleanup","focusSubscription","blurSubscription","undefined","useIsFocused","getNavigation","focused","setFocused","nav"],"mappings":"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","sourcesContent":["import {\n  useState,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport {\n  NavigationContext,\n  NavigationScreenProp,\n  NavigationRoute,\n  NavigationParams,\n  NavigationEventCallback,\n  NavigationEventPayload,\n  EventType,\n} from 'react-navigation';\n\nexport function useNavigation<S>(): NavigationScreenProp<S & NavigationRoute> {\n  const navigation = useContext(NavigationContext) as any; // TODO typing?\n  if (!navigation) {\n    throw new Error(\n      \"react-navigation hooks require a navigation context but it couldn't be found. \" +\n        \"Make sure you didn't forget to create and render the react-navigation app container. \" +\n        'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return'\n    );\n  }\n  return navigation;\n}\n\nexport function useNavigationParam<T extends keyof NavigationParams>(\n  paramName: T\n) {\n  return useNavigation().getParam(paramName);\n}\n\nexport function useNavigationState() {\n  return useNavigation().state;\n}\n\nexport function useNavigationKey() {\n  return useNavigation().state.key;\n}\n\n// Useful to access the latest user-provided value\nconst useGetter = <S>(value: S): (() => S) => {\n  const ref = useRef(value);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\nexport function useNavigationEvents(callback: NavigationEventCallback) {\n  const navigation = useNavigation();\n\n  // Closure might change over time and capture some variables\n  // It's important to fire the latest closure provided by the user\n  const getLatestCallback = useGetter(callback);\n\n  // It's important to useLayoutEffect because we want to ensure we subscribe synchronously to the mounting\n  // of the component, similarly to what would happen if we did use componentDidMount\n  // (that we use in <NavigationEvents/>)\n  // When mounting/focusing a new screen and subscribing to focus, the focus event should be fired\n  // It wouldn't fire if we did subscribe with useEffect()\n  useLayoutEffect(() => {\n    const subscribedCallback: NavigationEventCallback = event => {\n      const latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n\n    const subs = [\n      // TODO should we remove \"action\" here? it's not in the published typedefs\n      navigation.addListener('action' as any, subscribedCallback),\n      navigation.addListener('willFocus', subscribedCallback),\n      navigation.addListener('didFocus', subscribedCallback),\n      navigation.addListener('willBlur', subscribedCallback),\n      navigation.addListener('didBlur', subscribedCallback),\n    ];\n    return () => {\n      subs.forEach(sub => sub.remove());\n    };\n  }, [navigation.state.key]);\n}\n\nexport interface FocusState {\n  isFocused: boolean;\n  isBlurring: boolean;\n  isBlurred: boolean;\n  isFocusing: boolean;\n}\n\nconst emptyFocusState: FocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false,\n};\nconst didFocusState: FocusState = { ...emptyFocusState, isFocused: true };\nconst willBlurState: FocusState = { ...emptyFocusState, isBlurring: true };\nconst didBlurState: FocusState = { ...emptyFocusState, isBlurred: true };\nconst willFocusState: FocusState = { ...emptyFocusState, isFocusing: true };\n\nfunction nextFocusState(\n  eventName: EventType,\n  currentState: FocusState\n): FocusState {\n  switch (eventName) {\n    case 'willFocus':\n      return {\n        ...willFocusState,\n        // /!\\ willFocus will fire on screen mount, while the screen is already marked as focused.\n        // In case of a new screen mounted/focused, we want to avoid a isFocused = true => false => true transition\n        // So we don't put the \"false\" here and ensure the attribute remains as before\n        // Currently I think the behavior of the event system on mount is not very well specified\n        // See also https://twitter.com/sebastienlorber/status/1166986080966578176\n        isFocused: currentState.isFocused,\n      };\n    case 'didFocus':\n      return didFocusState;\n    case 'willBlur':\n      return willBlurState;\n    case 'didBlur':\n      return didBlurState;\n    default:\n      // preserve current state for other events (\"action\"?)\n      return currentState;\n  }\n}\n\nexport function useFocusState() {\n  const navigation = useNavigation();\n\n  const [focusState, setFocusState] = useState<FocusState>(() => {\n    return navigation.isFocused() ? didFocusState : didBlurState;\n  });\n\n  useNavigationEvents((e: NavigationEventPayload) => {\n    setFocusState(currentFocusState =>\n      nextFocusState(e.type, currentFocusState)\n    );\n  });\n\n  return focusState;\n}\n\ntype EffectCallback = (() => void) | (() => () => void);\n\n// Inspired by same hook from react-navigation v5\n// See https://github.com/react-navigation/hooks/issues/39#issuecomment-534694135\nexport const useFocusEffect = (callback: EffectCallback) => {\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    let isFocused = false;\n    let cleanup: (() => void) | void;\n\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    const focusSubscription = navigation.addListener('willFocus', () => {\n      // If callback was already called for focus, avoid calling it again\n      // The focus event may also fire on intial render, so we guard against runing the effect twice\n      if (isFocused) {\n        return;\n      }\n\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n\n    const blurSubscription = navigation.addListener('willBlur', () => {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n\n    return () => {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\n\nexport const useIsFocused = () => {\n  const navigation = useNavigation();\n  const getNavigation = useGetter(navigation);\n  const [focused, setFocused] = useState(navigation.isFocused);\n\n  useEffect(() => {\n    const nav = getNavigation();\n    const focusSubscription = nav.addListener('willFocus', () =>\n      setFocused(true)\n    );\n    const blurSubscription = nav.addListener('willBlur', () =>\n      setFocused(false)\n    );\n    return () => {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n\n  return focused;\n};\n"]}